<!DOCTYPE html>
<html>
  <head>
    <title>Interesting Modules</title>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="codes.css">
  </head>
  <body>
    <h1>Modules</h1>
    <h2>subprocess</h2>
    <p>
      One important method of Python that is frequently used by Linux user is <code> os.system("c") </code>.
      This is implemented by calling the Standard C function <code>system()</code>, and has the same limitations. 
      Changes to sys.stdin, etc. are not reflected in the environment of the executed command. If any output is generated, it will be sent to the interpreter standard output stream. For example, 
      <pre>
        os.system("leetcode user") 
      </pre>
     The standard output <em> [ERROR] You are not login yet? [0] </em> was not captured by this method. 
     Also, the command executed by <code>os.system</code> cannot be found, the program fail (more or less) silently without raise any error information. 
    </p>

    <p> To amend this, the module <code>subprocess</code> provides more powerful facilities for spawning new processes and retrieving their results. This module intends to replace several older modules and functions:
      <pre>
      os.system
      os.spawn*
      </pre>
    </p>

    <!-- starts with run -->
    <h3><code> .run </code> command</h3>
    <p>
      The recommended approach to invoking subprocesses is to use the <code> run() </code> function for all use cases it can handle. For more advanced use cases, the <strong> underlying <code> Popen </code> interface </strong> can be used directly. Thaat is <code> run </code> encapsulate <code> Popen </code>. The syntax is: 
      <pre>
        subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, capture_output=False, 
        shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None, text=None, 
        env=None, universal_newlines=None)
      </pre>

      Examples: 
      <pre>
        subprocess.run(["ls", "-l"])  # doesn't capture output
        CompletedProcess(args=['ls', '-lt'], returncode=0)

        output = subprocess.run(["ls", "-lt"], capture_output=True) # save output to output

        # To capture output and standard err
        result = subprocess.run(["ls", "-lt"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        print(result.stdout)
        print(result.stderr)

        # if you wish to redirect to /dev/null
        result = subprocess.run(["ls", "-lt"], stdout=devnull, stderr=devnull)
       </pre>
    </p>

    <p> Note, the <code>timeout</code> argument is passed to Popen.communicate(). If the timeout expires, the child process will be killed and waited for. The <code> TimeoutExpired </code> exception will be re-raised after the child process has terminated. Example a: you have to process to login <a href="https://www.twitter.com"> twitter </a> under unreliable network, you want to wait for no more than 10 seconds before killing the login procedure: 
      <pre>
        try:
          subprocess.run(["twitter", "login"], timeout=10)
        except subprocess.TimeoutExpired:
          print("Time out. Do something else.")
      </pre>
    </p>

    <h3><code>.Popen</code> command</h3>
    <p>
      <code>Popen.communicate()</code> returns a tuple <code>(stdout_data, stderr_data)</code>. The data will be strings if streams were opened in text mode; otherwise, bytes.
    </p>

    <h3>run vs Popen</h3>
    <p>
      subprocess.run was added in Python 3.5 as a simplification over subprocess.Popen when you just want to execute a command and wait until it finishes, but you don't want to do anything else meanwhile. For other cases, you still need to use subprocess.Popen.
    </p>

    <p> The main difference is that <strong>subprocess.run executes a command and waits for it to finish, while subprocess.Popen allows you to do other stuff before the process finishes and then just repeatedly call subprocess.communicate to pass and receive data to your process</strong>.
    </p>

    <p>
      Note that, what subprocess.run is actually doing is invoking for you the Popen and communicate, so you don't need to make a loop to pass/receive data nor wait for the process to finish.
    </p>


    <!-- Another Module -->
    <h2>numpy </h2>
    <p> At first, I thought <code>numpy</code> was a simple package for manipulating arrays with some functions such as <code>numpy.sum(), numpy.mean()</code>. It turns out that I've been ridiculously naive. Based on official documents: </p>
    <p>
      <a href="http://www.numpy.org">NumPy</a> is the fundamental package for scientific computing with Python. It contains among other things:
      <ul>
        <li> a powerful N-dimensional array object </li>
        <li> sophisticated (broadcasting) functions </li>
        <li> tools for integrating C/C++ and Fortran code</li>
        <li> useful linear algebra, Fourier transform, and random number capabilities</li>
      </ul>

      A quickstart tutorial can be found <a href="https://docs.scipy.org/doc/numpy/user/quickstart.html">here</a>. 
    </p>

    <p> I can't write better a document than the official one, but list in the following some regularly used functions that may be considered helpful for future reference. </p>

    <pre>
      import numpy

      arr = [1, 3, 4]
      print("The sum: ", numpy.sum(arr))
      print("The mean: ", numpy.mean(arr))
      print("The size: ", numpy.size(arr))

      # 9 numbers from 0 to 2
      arr = numpy.linspace( 0, 2, 9)
      print(arr)
      print(len(arr))

      ----------------- 
      The sum:  8
      The mean:  2.6666666666666665
      The size:  3
      [0.   0.25 0.5  0.75 1.   1.25 1.5  1.75 2.  ]
      9
    </pre>


    <h2>json & csv</h2>
    <h3>json syntax</h3>
    <pre>
      import json
      output = json.load(open('ss.json', 'r'))
      print(type(output))
      # class 'dict'

      json_data = '{"server": "google.com", "city": "New York", "port": "9988"}'
      output = json.loads(json_data)
      print(type(output))  # output class 'dict'

      # use dumps to tidy up date
      print(json.dumps({"server": "google.com", "city": "New York",
                  "port": "9988"}, sort_keys=True, indent=4, separators=(',', ': ')))
      # result 
      {
            "city": "New York",
            "port": "9988",
            "server": "google.com"
      }

    </pre>


    <p>
      A typical .csv file looks like the following one. And codes below will first read the file, and returns a <code>_csv.reader</code> object, a reader object which will iterate over lines in the given csf file. 
    </p>
    <pre>
      with open('stocks.csv') as f:
        f_csv = csv.reader(f) # type(f_csv) = _csv.reader
        headers = next(f_csv)
        for row in f_csv:
          ... 
    </pre>
    
    <iframe src="data/f.txt" width=500 height=150 frameborder=3 style="border-radius: 10px"></iframe>

    <p>
      To Create an object that operates like a regular reader but maps the information in each row to an OrderedDict whose keys are given by the optional <code>fieldnames</code> parameter, we can use the <code>DictReader</code> method. 
    </p>
    
    <pre>
       dr = csv.DictReader(open('f.csv', 'r'))   
       print(dr.fieldnames)   # ['Symbol', 'Price', 'Date', 'Time', 'Change', 'Volume']
    </pre>

  </body>
</html>


