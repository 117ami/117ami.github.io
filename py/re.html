<!DOCTYPE html>
<html>
  <head>
    <title>Fluent Python</title>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="../io.css">
  </head>
  <body>

  	<h2>Python regular expression</h2>
  	<h3> Quick Keywords </h3>
  	<p>
  		[<a href="#match">re.match()</a>, <a href="#search">re.search()</a>, <a href="#findall">re.findall()</a>, 
  		<a href="#split">re.split()</a>]
  	</p>

  	<p> Question: re.match, findall, search, what are the differences and when to use them ?</p>
  	<h3 id="match"> <code> re.match(pattern, string, flags=0) </code> </h3>
  	<p> 
  		<ul>
  			<li><em>usage</em> : if zero or more characters at the <emph> beginning of string (not the beginning of each line) </emph> match the regular expression pattern, return a corresponding <code> match object </code>, or Noe otherwise.  

  			</li>
  			<li><em>:rtye:</em> match object || None </li>
  			<li><em>Exmaple</em>:
  				<pre>
  					>>> print(re.match('blue', 'red blue\nblue')) 
  					None
  					>>> print(re.match('blue', 'bluered\nblue')) 
  					re.Match object; span=(0, 4), match='blue'
  				</pre>
  			</li>
  		</ul>

	</p>

	<p> To locate a match anywhere in string, we should use <code><a href="#search">search()</a></code> instead. </p>

  	<h3 id="search"> <code> re.search(pattern, string, flags=0) </code> </h3>
  	<p> 
  		<ul>
  			<li><em>usage</em> : scans through string looking for the <emph>first location</emph> where the regular expression pattern produces a match, returns a corresponding match object, and None otherwise.
  			</li>
  			<li><em>:rtye:</em> match object || None </li>
  			<li><em>Exmaple</em>:
  				<pre>
  					>>> print(re.match('blue', 'bluered\nblue')) 
  					re.Match object; span=(4, 8), match='blue'
  				</pre>
  			</li>
  		</ul>
	</p>

  	<h3 id="findall"> <code> re.findall(pattern, string, flags=0) </code> </h3>
  	<p> 
  		<ul>
  			<li><em>usage</em> : scan the string from left to right to find all non-overlapping matches of pattern in string, and returns them as a list of strings. 
  			</li>
  			<li><em>:rtye:</em> a list of string </li>
  			<li><em>Exmaple</em>:
  				<pre>
  					>>> print(re.findall(r'blue.*d', 'pbluered\nflying blue bird')) 
  					['bluered', 'blue bird']
  					>>> print(re.findall(r'blue', 'red green yellow'))   					
  					[] / empty list
  					>>> text = "ash is the purest white"
  					>>> print(re.findall(r'\w+e', text))
  					['the', 'pure', 'white']
  				</pre>
  			</li>
  			<li> <em>notes</em>: findall() will search for all occurrences matching the given pattern, whitespace has no influence to the results. Thus, to find all words ending with 'e' in a string, the code in the above example is incorrect. However, 
  				<pre>
  					>>> print(re.findall(r'\w+e(?!\w+)', text))
  					['the', 'white']
  				</pre>
  				will do the work.
  			</li>
  		</ul>
	</p>

	<h3>short summary</h3>
	<p>
		<ul>
			<li> use <a href="#match">match()</a> when deciding whether a pattern is matched at the beginning of a string</li>
			<li> use <a href="#search">search()</a> when deciding whether a pattern is match in anywhere of a string </li>
			<li> use <a href="#findall">findall()</a> when searching for all occurrences of a pattern in a string </li>			
		</ul>
	</p>

	<h2>More interesting methods</h2>
	<h3 id="split"> <code> re.split(pattern, string, maxsplit=n, flags=0) </code> </h3>
  	<p> 
  		<ul>
  			<li><em>usage</em> : split string by occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. <br>
  				if <code>maxsplit</code> is non-zero, at most n splits occur.
  			</li>
  			<li><em>:rtye:</em> a list of string </li>
  			<li><em>Exmaple</em>:
  				<pre>
  					>>> print(re.split(r'\W+', 'Mission impossible 7.53=25'))
  					['Mission', 'impossible', '7', '53', '25']
  					>>> print(re.split(r'(\W+)', 'Mission impossible 7.53=25'))  					
  					# also capturing all the separators 
  					['Mission', ' ', 'impossible', ' ', '7', '.', '53', '=', '25']
  					>>> print(re.split(r'(\W+)', 'Mission impossible 7.53=25', 2))
  					['Mission', 'impossible', '7.53=25']
  				</pre>
  			</li>
  		</ul>
	</p>

	<p> Compared with String | spit(), which returns a list of strings after breaking the given string by the specified separator, <a href="#split">re.split()</a> is much more powerful, since it supports pattern matching that normal split doesn't. The usages are similar, both supports max splits and capturing.
	</p>


  </body>
</html>
